<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<!-- TODO list
- Get TODO extension
- full screen the browser
- autodetect screen size

âœ“ refactor to class 
-->


<!-- FUTURE IDEAS
Swarm Wars
A New Hive

The evil sith queen knows of your existence and has sent drone droids to destroy you.
You flee with a rebel army of sister clones.
As you emerge from hyperspace, you set course for a new hive.

May the course be with you.
-->

<body>
  <button id="startBtn" onClick="toggleFullScreen()">Toggle Full Screen</button>
  <main></main>
      
<script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>

<script>
function toggleFullScreen() {
  let fs = fullscreen()
  fullscreen(!fs)
}

// let globalFlock
let redFlock
let blueFlock
let greenFlock
let purpleFlock
let yellowFlock

function setup() {
  // createCanvas(720, 400)
  createCanvas(windowWidth-30, windowHeight-44)

  // globalFlock = new Flock()
  // let queen
  // Add an initial set of boids into the system
  redFlock = new Flock()
  // queen = new Boid(width*(3/8), height*.25, 0, 1, 'red')
  // queen.r = 6
  // redFlock.addBoid(queen)
  // globalFlock.addBoid(queen)
  for (let i = 0; i < 3; i++) {
    let b = new Boid(random(width*.25, width*.50), height*.25, random(-1, 1), random(0, 1), 'red', random(6,8))
    redFlock.addBoid(b)
    // globalFlock.addBoid(b)
  }

  purpleFlock = new Flock()
  // queen = new Boid(width*(5/8), height*.25, 0, 1, 'purple')
  // queen.r = 6
  // purpleFlock.addBoid(queen)
  // // globalFlock.addBoid(queen)
  for (let i = 0; i < 7; i++) {
    let b = new Boid(random(width*.50, width*.75), height*.25, random(-1, 1), random(0, 1), '#ffffcc', random(3,6))
    purpleFlock.addBoid(b)
    // globalFlock.addBoid(b)
  }

  blueFlock = new Flock()
  // queen = new Boid(width*(3/8), height*.75, 0, -1, 'blue')
  // queen.r = 6
  // blueFlock.addBoid(queen)
  // // globalFlock.addBoid(queen)
  for (let i = 0; i < 20; i++) {
    let b = new Boid(random(width*.25, width*.50), height*.75, random(-1, 1), random(-1, 0), 'blue', random(2,4))
    blueFlock.addBoid(b)
    // globalFlock.addBoid(b)
  }

  greenFlock = new Flock()
  // queen = new Boid(width*(5/8), height*.75, 0, -1, 'green')
  // queen.r = 6
  // greenFlock.addBoid(queen)
  // // globalFlock.addBoid(queen)
  for (let i = 0; i < 200; i++) {
    let b = new Boid(random(width*.50, width*.75), height*.75, random(-1, 1), random(-1, 0), 'green',  random(1,3)/2)
    greenFlock.addBoid(b)
    // globalFlock.addBoid(b)
  }

}

function draw() {
  background(0)
  // fill('blue')
  // ellipse(width*(1/4), 50, 50, 40)
  // ellipse(width*(1/4), 60, 80, 20)
  // ellipse(width*(1/4), 70, 100, 20)
  // fill('black')
  // circle(width*(1/4), 70, 10)
  
  // fill('green')
  // ellipse(width*(3/4), 50, 50, 40)
  // ellipse(width*(3/4), 60, 80, 20)
  // ellipse(width*(3/4), 70, 100, 20)
  // fill('black')
  // circle(width*(3/4), 70, 10)
  
  // fill('red')
  // ellipse(width*(1/4), height-70, 50, 40)
  // ellipse(width*(1/4), height-60, 80, 20)
  // ellipse(width*(1/4), height-50, 100, 20)
  // fill('black')
  // circle(width*(1/4), height-50, 10)
  
  // fill('purple')
  // ellipse(width*(3/4), height-70, 50, 40)
  // ellipse(width*(3/4), height-60, 80, 20)
  // ellipse(width*(3/4), height-50, 100, 20)
  // fill('black')
  // circle(width*(3/4), height-50, 10)

  // globalFlock.run()
  // console.log(redFlock, blueFlock, greenFlock, purpleFlock)
  // redFlock.run()
  blueFlock.run()
  greenFlock.run()
  purpleFlock.run()
}

// Add a new boid into the System
// function mouseDragged() {
//   globalFlock.addBoid(new Boid(mouseX, mouseY, random(-1, 1), random(-1, 1), 'white'))
// }



// Flock object
// Does very little, simply manages the array of all the boids

class Flock {
  
  constructor() {
    // console.log('Flock')
    this.boids = [] // Initialize the array
  }

  run() {
    for (let boid of this.boids) {
      boid.run(this.boids)  // Passing the entire list of boids to each boid individually
    }
  }
  
  addBoid(b) {
    this.boids.push(b)
  }
}


class Boid {
  
  constructor(x, y, vx, vy, color, r=3.0) {
    this.acceleration = createVector(0, 0)
    this.velocity = createVector(vx, vy)
    this.position = createVector(x, y)
    this.r = r
    this.maxspeed = 3    // Maximum speed
    this.maxforce = 0.05 // Maximum steering force
    this.color = color
  }

  run(boids) {
    this.flock(boids)
    this.update()
    // this.borders()
    this.render()
  }

  applyForce(force) {
    // We could add mass here if we want A = F / M
    this.acceleration.add(force)
  }

  // We accumulate a new acceleration each time based on three rules
  flock(boids) {
    let sep = this.separate(boids)   // Separation
    let ali = this.align(boids)      // Alignment
    let coh = this.cohesion(boids)   // Cohesion
    let atr = this.attractions()     // Attractions
    let rep = this.repulsions()      // Repulsions
    // Arbitrarily weight these forces
    sep.mult(1.5)
    ali.mult(1.0)
    coh.mult(1.0)
    atr.mult(1.0)
    rep.mult(1.0)
    // Add the force vectors to acceleration
    this.applyForce(sep)
    this.applyForce(ali)
    this.applyForce(coh)
    this.applyForce(atr)
    this.applyForce(rep)
  }

  // Method to update location
  update() {
    // Update velocity
    this.velocity.add(this.acceleration)
    // Limit speed
    this.velocity.limit(this.maxspeed)
    this.position.add(this.velocity)
    // Reset accelertion to 0 each cycle
    this.acceleration.mult(0)
  }

  // A method that calculates and applies a steering force towards a target
  // STEER = DESIRED MINUS VELOCITY
  seek(target) {
    let desired = p5.Vector.sub(target, this.position)  // A vector pointing from the location to the target
    // Normalize desired and scale to maximum speed
    desired.normalize()
    desired.mult(this.maxspeed)
    // Steering = Desired minus Velocity
    let steer = p5.Vector.sub(desired, this.velocity)
    steer.limit(this.maxforce)  // Limit to maximum steering force
    return steer
  }

  render() {
    // Draw a triangle rotated in the direction of velocity
    let theta = this.velocity.heading() + radians(90)
    fill(this.color)
    // stroke(200)
    push()
    translate(this.position.x, this.position.y)
    rotate(theta)
    beginShape()
    // TRIANGLE
    // vertex(0, -this.r * 2)
    // vertex(-this.r, this.r * 2)
    // vertex(this.r, this.r * 2)

    // FISH
    vertex(0, -this.r * 1.5) // mouth
    vertex(-this.r/2, -this.r)    // left body upper
    vertex(-this.r * 1.5, this.r*.5)  // left fin
    vertex(-this.r/2, -this.r/20)  // left body lower
    vertex(-this.r, this.r * 2)   // left tail
    vertex(0, this.r * 1.6)  // between tail
    vertex(this.r, this.r * 2)    // right tail
    vertex(this.r/2, -this.r/20)  // right body lower
    vertex(this.r * 1.5, this.r*.5)  // right fin
    vertex(this.r/2, -this.r)    // right body upper
    endShape(CLOSE)
    ellipse(0, 0, this.r*1.5, this.r * 3.5 )
    pop()
  }

  // Wraparound
  borders() {
    if (this.position.x < this.r)          this.position.x = width  + this.r
    if (this.position.y < this.r)          this.position.y = height + this.r
    if (this.position.x > width  - this.r) this.position.x = -this.r
    if (this.position.y > height - this.r) this.position.y = -this.r
  }

  // Separation
  // Method checks for nearby boids and steers away
  separate(boids) {
    let desiredseparation = 25.0
    let steer = createVector(0, 0)
    let count = 0
    // For every boid in the system, check if it's too close
    for (let boid of boids) {
      let d = p5.Vector.dist(this.position, boid.position)
      // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
      if ((d > 0) && (d < desiredseparation)) {
        // Calculate vector pointing away from neighbor
        let diff = p5.Vector.sub(this.position, boid.position)
        diff.normalize()
        diff.div(d)        // Weight by distance
        steer.add(diff)
        count++            // Keep track of how many
      }
    }
    // Average -- divide by how many
    if (count > 0) {
      steer.div(count)
    }

    // As long as the vector is greater than 0
    if (steer.mag() > 0) {
      // Implement Reynolds: Steering = Desired - Velocity
      steer.normalize()
      steer.mult(this.maxspeed)
      steer.sub(this.velocity)
      steer.limit(this.maxforce)
    }
    return steer
  }

  // Alignment
  // For every nearby boid in the system, calculate the average velocity
  align(boids) {
    let neighbordist = 50
    let sum = createVector(0,0)
    let count = 0
    for (let boid of boids) {
      let d = p5.Vector.dist(this.position, boid.position)
      if ((d > 0) && (d < neighbordist)) {
        sum.add(boid.velocity)
        count++
      }
    }
    if (count > 0) {
      sum.div(count)
      sum.normalize()
      sum.mult(this.maxspeed)
      let steer = p5.Vector.sub(sum, this.velocity)
      steer.limit(this.maxforce)
      return steer
    } else {
      return createVector(0, 0)
    }
  }

  // Cohesion
  // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location
  cohesion(boids) {
    let neighbordist = 50
    let sum = createVector(0, 0)   // Start with empty vector to accumulate all locations
    let count = 0
    for (let boid of boids) {
      let d = p5.Vector.dist(this.position, boid.position)
      if ((d > 0) && (d < neighbordist)) {
        sum.add(boid.position) // Add location
        count++
      }
    }
    if (count > 0) {
      sum.div(count)
      return this.seek(sum)  // Steer towards the location
    } else {
      return createVector(0, 0)
    }
  }

  attractions() {
    return createVector(0,0)
  }

  repulsions() {
    const w = 10 // distance from (w)all before repulsion kicks in
    const walls = [
      {position: createVector(this.position.x, 0)},
      {position: createVector(this.position.x, height-1)},
      {position: createVector(0, this.position.y)},
      {position: createVector(width-1, this.position.y)},
    ]
    // fill('white')
    // for (let wall of walls) {
    //   circle(wall.position.x, wall.position.y, 10)
    // }
    // return this.separate(walls)
    let boids = walls
    let desiredseparation = 10.0
    let steer = createVector(0, 0)
    let count = 0
    // For every boid in the system, check if it's too close
    for (let boid of boids) {
      let d = p5.Vector.dist(this.position, boid.position)
      // if (d < 0) console.error('negative distance!!!')
      // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
      if (d < desiredseparation) {
        // Calculate vector pointing away from neighbor
        let diff = p5.Vector.sub(this.position, boid.position)
        // diff.normalize()
        // diff.div(d)        // Weight by distance
        steer.add(diff)
        // count++            // Keep track of how many
      }
    }
    return steer
    // return createVector(0, 0)
    // Average -- divide by how many
    // if (count > 0) {
    //   steer.div(count)
    // }

    // As long as the vector is greater than 0
    // if (steer.mag() > 0) {
    //   // Implement Reynolds: Steering = Desired - Velocity
    //   steer.normalize()
    //   steer.mult(this.maxspeed)
    //   steer.sub(this.velocity)
    //   steer.limit(this.maxforce)
    // }
    const {x,y} = this.position
    let dx = Math.abs(width - x)
    let dy = Math.abs(height - y)

    if (dx > w) return createVector(0, 0)
    if (dy > w) return createVector(0, 0)

    if (x <=w) return createVector(w, 0).mult(this.maxspeed).sub(this.velocity).limit(this.maxforce)
    if (x > width-w) return createVector(-w, 0).mult(this.maxspeed).sub(this.velocity).limit(this.maxforce)
    if (y <=w) return createVector(0, w).mult(this.maxspeed).sub(this.velocity).limit(this.maxforce)
    if (y > height-w) return createVector(0, -w).mult(this.maxspeed).sub(this.velocity).limit(this.maxforce)

    // if (width - x < w) {
    //   wall = createVector(0, this.position.y)
    //   // console.log(w, width, x, w - width - x)
    //   return createVector(-2 * (w - (width - x))/w, 0)
    // }
    // let d = p5.Vector.dist(this.position, )
    // // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
    // if ((d > 0) && (d < desiredseparation)) {
    //     // Calculate vector pointing away from neighbor
    //     let diff = p5.Vector.sub(this.position, boid.position)
    //     diff.normalize()
    //     diff.div(d)           
// ------------------------------------------

    // if (x < w) { // (1 - (w-x)) / 25
    //   return createVector( 2*(w-x)/w)     //w/(w-x), 0) ///(25-this.position.x)
    // }
  
    // if (width - x < w) {
    //   // console.log(w, width, x, w - width - x)
    //   return createVector(-2 * (w - (width - x))/w, 0)
    // }

    // if (y > height) return createVector(0, 0)
    // if (y < 0) return createVector(0, 0)

    // if (y < w) {
    //   return createVector(0, w/(w-y)) ///(25-this.position.x)
    // }
  
    // if (height - y < w) {
    //   // console.log(w, width, x, w - width - x)
    //   return createVector(0,-w/(w - (height - y)))
    // }

    // return createVector(0, 0)
  }
}
// Original:
// The Nature of Code
// Daniel Shiffman
// http://natureofcode.com
//
// Modified:
// David Wagstaff
</script>
</body>
</html>
